# Lisp(Scheme)言語でソートアルゴリズムの復習

高級言語のようにfor文やwhile文が無いため、
ループ処理は基本的に再帰的に行う。

## バブルソート

|引数|役割|
|---|---|
|list|バブルソート対象のlistを格納する。最大値が評価される度に `tempList` をリセットするための引数|
|tempList|評価後の最大値が常に一番左端にある状態として処理する引数。処理途中で大なり判定の際に偽であった数値は常に除いている。また `result` に含まれる数値を大なり判定で評価しないようにしている。|
|count| `targetList` のlength回分評価させることによりバブルソートを行っている|
|result| `tempList` のlengthが1になる度にn純目の最大値を左端に加えている|

### 見えた課題

#### list型の長さを取得する方法に統一感が無い

配列の長さを、

```scheme
(if (> (length list) 0)
    #t
    #f
)
```

や

```scheme
(if (> (length (cdr list)) 0)
    #t
    #f
)
```

の2通りで取得し判定を行っているが、どちらかに統一したい。

#### スコープを意識すれば引数を削れそう

listやcount、resultはスコープを意識して書き直せば削れそう。

#### consでは無くappendで配列を結合したほうが短くなる

わざわざ↓のようにcarで取り出した値をconsで結合するより、

```scheme
(cons (car list) result)
```

↓のようにappendで結合したほうが短く表現できる。

```scheme
(append list result)
```

結合するタイミングは `tempList` のlengthが1の時のみで、
あえて `cons` で結合する必要は無く `append` でも同様の立ち回りが可能なため。

#### 理にかなう返り値となっている場合には即刻breakさせる

現状の実装だと、いかなる場合であっても `(* (length targetList) 2)`回分再帰処理を行っている。
理にかなう返却値を担保できる時点でbreakさせる実装にfixさせれば、無駄な処理を大幅に省ける